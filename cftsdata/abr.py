'''
Interface for reading tone-evoked ABR data generated by psiexperiment

This supports merging across aggregate files. Right now there's no support for
reading from the raw (i.e., untrial_filtered) data. Maybe eventually. It wouldn't be
hard to add, but would need support for trial_filter specs as well as ensuring that we
pull out enough pre/post samples for proper trial_filtering.
'''
import logging
log = logging.getLogger(__name__)

import functools
import os.path
import shutil
import re
from glob import glob

import bcolz
import numpy as np
import pandas as pd
from scipy import signal

from .bcolz_tools import Dataset, load_ctable_as_df, repair_carray_size


MERGE_PATTERN = \
    r'\g<date>-* ' \
    r'\g<experimenter> ' \
    r'\g<animal> ' \
    r'\g<ear> ' \
    r'\g<note> ' \
    r'\g<experiment>*'


class ABRFile(Dataset):

    def __init__(self, *args, **kw):
        super().__init__(*args, **kw)
        if 'eeg' not in self.carray_names:
            raise ValueError('Missing eeg data')
        if 'erp_metadata' not in self.ctable_names:
            raise ValueError('Missing eeg data')

    @property
    def eeg(self):
        # Load and ensure that the EEG data is fine. If not, repair it and
        # reload the data.
        rootdir = self.base_folder / 'eeg'
        eeg = bcolz.carray(rootdir=rootdir)
        if len(eeg) == 0:
            log.debug('EEG for %s is corrupt. Repairing.', self.base_folder)
            repair_carray_size(rootdir)
            eeg = bcolz.carray(rootdir=rootdir)
        return eeg

    def get_epochs(self, offset=0, duration=8.5e-3, padding_samples=0,
                   detrend='constant', base_name='target_tone_',
                   columns=['frequency', 'level', 'polarity']):

        if columns is None:
            columns = []
        names = columns
        if base_name is not None:
            columns = [f'{base_name}{c}' for c in columns]
        result = super().get_epochs(self.eeg, self.erp_metadata, offset,
                                    duration, padding_samples, columns)
        result.index.names = names + ['t0']
        if detrend is not None:
            result[:] = signal.detrend(result.values, type=detrend, axis=1)
        return result

    def get_epochs_filtered(self, filter_lb=300, filter_ub=3000,
                            filter_order=1, offset=-1e-3, duration=10e-3,
                            detrend='constant', pad_duration=10e-3,
                            base_name='target_tone_', columns=None):

        fs = self.eeg.attrs['fs']
        Wn = (filter_lb/fs, filter_ub/fs)
        b, a = signal.iirfilter(filter_order, Wn, btype='band', ftype='butter')
        padding_samples = round(pad_duration*fs)
        df = self.get_epochs(offset, duration, padding_samples, detrend,
                             base_name, columns)

        # The vectorized approach takes up too much memory on some of the older
        # NI PXI systems. Hopefully someday we can move away from all this!
        epochs_filtered = []
        for epoch in df.values:
            e = signal.filtfilt(b, a, epoch)
            e = e[padding_samples:-padding_samples]
            epochs_filtered.append(e)

        columns = df.columns[padding_samples:-padding_samples]
        return pd.DataFrame(epochs_filtered, index=df.index, columns=columns)


class ABRSupersetFile:

    def __init__(self, *base_folders):
        self._fh = [ABRFile(base_folder) for base_folder in base_folders]

    def get_epochs_filtered(self, *args, **kwargs):
        epoch_set = []
        keys = []
        for fh in self._fh:
            epochs = fh.get_epochs_filtered(*args, **kwargs)
            keys.append(os.path.basename(fh._base_folder))
            epoch_set.append(epochs)
        return pd.concat(epoch_set, keys=keys, names=['file'])

    @classmethod
    def from_pattern(cls, base_folder):
        head, tail = os.path.split(base_folder)
        glob_tail = FILE_RE.sub(MERGE_PATTERN, tail)
        glob_pattern = os.path.join(head, glob_tail)
        folders = glob(glob_pattern)
        inst = cls(*folders)
        inst._base_folder = base_folder
        return inst

    @classmethod
    def from_folder(cls, base_folder):
        folders = [os.path.join(base_folder, f) \
                   for f in os.listdir(base_folder)]
        inst = cls(*[f for f in folders if os.path.isdir(f)])
        inst._base_folder = base_folder
        return inst

    @property
    def erp_metadata(self):
        return pd.concat([fh.erp_metadata for fh in self._fh],
                         ignore_index=True)


def load(base_folder):
    check = os.path.join(base_folder, 'erp')
    if os.path.exists(check):
        return ABRFile(base_folder)
    else:
        return ABRSupersetFile.from_folder(base_folder)


def is_abr_experiment(path):
    try:
        load(path)
        return True
    except Exception:
        return False
